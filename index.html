<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PocketPath: WSI Analysis</title>
    
    <!-- 1. Import Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web@1.16.3/dist/ort.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/geotiff@2.1.0/dist-browser/geotiff.js"></script>
    
    <style>
        /* --- BASE STYLES --- */
        :root { --primary: #0066cc; --bg: #f4f6f8; --text: #333; }
        * { box-sizing: border-box; }
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 15px; background: var(--bg); color: var(--text); }
        
        h1 { margin: 0.5rem 0 0.2rem 0; font-size: 1.5rem; color: #1a1a1a; letter-spacing: -0.5px; }
        p.subtitle { margin: 0 0 1.5rem 0; color: #666; font-size: 0.9rem; line-height: 1.4; }

        /* --- LAYOUT --- */
        .container { display: flex; flex-direction: column; gap: 20px; max-width: 1200px; margin: 0 auto; }
        
        /* Desktop: Side-by-Side */
        @media (min-width: 900px) {
            .container { display: grid; grid-template-columns: 1fr 1.2fr; align-items: start; }
            h1 { font-size: 2rem; }
        }

        /* Cards */
        .card { background: white; padding: 20px; border-radius: 16px; box-shadow: 0 4px 12px rgba(0,0,0,0.05); }
        h3 { margin-top: 0; padding-bottom: 10px; border-bottom: 2px solid #f0f0f0; font-size: 1.1rem; color: #444; }

        /* --- UPLOAD COMPONENTS --- */
        .upload-group { margin-bottom: 15px; }
        .upload-box { 
            border: 2px dashed #cbd5e1; border-radius: 12px; padding: 15px; 
            text-align: center; background: #f8fafc; transition: 0.2s; position: relative;
        }
        .upload-box:active, .upload-box:hover { border-color: var(--primary); background: #f0f9ff; }
        .upload-box.loaded { border-color: #10b981; background: #ecfdf5; }
        
        .upload-label { font-weight: 600; font-size: 0.9rem; display: block; margin-bottom: 4px; }
        .upload-sub { font-size: 0.75rem; color: #64748b; display: block; margin-bottom: 8px; }
        
        /* Custom File Input styling */
        input[type="file"] { width: 100%; font-size: 0.85rem; }

        /* Model List */
        #model-list { list-style: none; padding: 0; margin: 10px 0 0 0; }
        #model-list li { 
            background: white; border: 1px solid #e2e8f0; padding: 8px 12px; 
            margin-top: 6px; border-radius: 8px; font-size: 0.8rem; 
            display: flex; justify-content: space-between; align-items: center;
        }
        #model-list li .name { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 150px; font-weight: 600; }

        /* --- VISUALIZATION --- */
        #wsi-wrapper { 
            position: relative; width: 100%; background: #000; 
            border-radius: 12px; overflow: hidden; border: 1px solid #ddd;
            /* Aspect Ratio Placeholder */
            min-height: 250px; display: flex; align-items: center; justify-content: center;
        }
        #wsi-vis { max-width: 100%; max-height: 400px; object-fit: contain; display: block; }
        
        /* Progress Bar */
        .status-bar { margin-top: 20px; }
        .progress-track { height: 8px; background: #e2e8f0; border-radius: 4px; overflow: hidden; }
        .progress-fill { height: 100%; width: 0%; background: var(--primary); transition: width 0.2s; }
        .status-text { display: flex; justify-content: space-between; font-size: 0.8rem; color: #64748b; margin-top: 6px; font-weight: 500; }

        /* --- RESULTS TABLE --- */
        .table-wrap { overflow-x: auto; margin-top: 15px; }
        .results-table { width: 100%; border-collapse: collapse; font-size: 0.9rem; min-width: 300px; }
        .results-table th { text-align: left; border-bottom: 2px solid #f1f5f9; padding: 10px 5px; color: #64748b; font-size: 0.8rem; text-transform: uppercase; }
        .results-table td { border-bottom: 1px solid #f1f5f9; padding: 10px 5px; vertical-align: middle; }
        
        .badge { padding: 4px 8px; border-radius: 6px; font-weight: 700; font-size: 0.75rem; letter-spacing: 0.5px; }
        .badge.pos { background: #fef2f2; color: #ef4444; border: 1px solid #fee2e2; }
        .badge.neg { background: #f0fdf4; color: #16a34a; border: 1px solid #dcfce7; }

        /* --- CONTROLS --- */
        .controls-area { margin-top: 20px; }
        
        .viz-toggle { 
            display: flex; align-items: center; padding: 12px; 
            background: #f8fafc; border-radius: 8px; font-size: 0.9rem; 
            cursor: pointer; border: 1px solid #e2e8f0; margin-bottom: 15px;
        }
        .viz-toggle input { margin-right: 10px; width: 18px; height: 18px; }

        #btn-run { 
            background: var(--primary); color: white; border: none; 
            padding: 16px; font-size: 1rem; font-weight: 700; 
            border-radius: 10px; cursor: pointer; width: 100%; 
            box-shadow: 0 4px 6px rgba(0, 102, 204, 0.2);
            transition: transform 0.1s;
        }
        #btn-run:disabled { background: #cbd5e1; box-shadow: none; cursor: not-allowed; }
        #btn-run:active:not(:disabled) { transform: scale(0.98); }

        /* Console */
        #console { 
            background: #1e293b; color: #4ade80; font-family: "Menlo", monospace; 
            padding: 15px; border-radius: 12px; height: 150px; 
            overflow-y: auto; font-size: 11px; margin-top: 20px; 
            line-height: 1.5;
        }
        .log-err { color: #f87171; }
        
        /* Level Selector */
        #level-select { width: 100%; padding: 10px; border-radius: 8px; border: 1px solid #cbd5e1; background: white; font-size: 0.9rem; }

    </style>
</head>
<body>

    <h1>üß¨ PocketPath</h1>
    <p class="subtitle">Client-Side WSI Biomarker Prediction.<br>No Server. 100% Privacy.</p>

    <div class="container">
        <!-- LEFT: SETUP -->
        <div class="card">
            <h3>1. Configuration</h3>
            
            <!-- Backbone -->
            <div class="upload-group">
                <div class="upload-box" id="box-backbone">
                    <span class="upload-label">1. Backbone Model</span>
                    <span class="upload-sub">Select <code>mobileone.onnx</code></span>
                    <input type="file" id="file-backbone" accept=".onnx">
                </div>
            </div>

            <!-- Classifiers -->
            <div class="upload-group">
                <div class="upload-box" id="box-classifiers">
                    <span class="upload-label">2. Classifiers (STAMP)</span>
                    <span class="upload-sub">Select multiple .onnx files</span>
                    <input type="file" id="file-classifiers" accept=".onnx" multiple>
                    <ul id="model-list"></ul>
                </div>
            </div>

            <!-- Slide -->
            <div class="upload-group">
                <div class="upload-box" id="box-slide">
                    <span class="upload-label">3. Whole Slide Image</span>
                    <span class="upload-sub">Select .tif / .tiff</span>
                    <input type="file" id="file-slide" accept=".tif,.tiff">
                </div>
                
                <!-- Level Selector (Hidden until loaded) -->
                <div id="level-container" style="display:none; margin-top: 10px;">
                    <label for="level-select" style="font-size:0.85rem; font-weight:600; color:#555; display:block; margin-bottom:5px;">Magnification Level:</label>
                    <select id="level-select"></select>
                </div>
            </div>

            <div class="controls-area">
                <label class="viz-toggle">
                    <input type="checkbox" id="cb-viz" checked> 
                    <span><strong>Live Map</strong> (Uncheck for speed)</span>
                </label>
                <button id="btn-run" disabled>üöÄ Run Analysis</button>
            </div>
        </div>

        <!-- RIGHT: RESULTS -->
        <div class="card">
            <h3>2. Real-Time View</h3>
            <div id="wsi-wrapper">
                <canvas id="wsi-vis"></canvas>
            </div>

            <div class="status-bar">
                <div class="progress-track"><div id="p-bar" class="progress-fill"></div></div>
                <div class="status-text">
                    <span id="p-status">Waiting to start...</span>
                    <span id="p-percent">0%</span>
                </div>
            </div>

            <div class="table-wrap">
                <table class="results-table">
                    <thead>
                        <tr>
                            <th>Biomarker</th>
                            <th>Result</th>
                            <th>Prob</th>
                        </tr>
                    </thead>
                    <tbody id="results-body">
                        <tr><td colspan="3" style="text-align:center; padding: 20px; color:#999;">Load models and slide to begin</td></tr>
                    </tbody>
                </table>
            </div>
            
            <div id="console">
                <div>System Initialized.</div>
            </div>
        </div>
    </div>

    <!-- Hidden Processing Canvas -->
    <canvas id="proc-canvas" width="224" height="224" style="display:none;"></canvas>

    <script>
        // --- GLOBAL HANDLERS ---
        window.onerror = function(message, source, lineno, colno, error) {
            log(`CRITICAL ERROR: ${message}`, true);
            return false;
        };

        // --- CONFIG ---
        const TILE_SIZE = 224;
        const MAX_PREVIEW_PIXELS = 10000000;

        // --- STATE ---
        let backboneSess = null;
        let classifiers = []; 
        let tiff = null;
        let tiffImage = null;

        // --- UTILS ---
        const log = (msg, err=false) => {
            const c = document.getElementById('console');
            if(!c) return;
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            if(err) div.classList.add('log-err');
            c.appendChild(div);
            c.scrollTop = c.scrollHeight;
        };

        // --- COLOR & PIXEL UTILS ---
        function ycbcrToRgb(y, cb, cr) {
            const c = y - 16;
            const d = cb - 128;
            const e = cr - 128;
            return [
                Math.max(0, Math.min(255, (1.164 * c + 1.596 * e))),
                Math.max(0, Math.min(255, (1.164 * c - 0.391 * d - 0.813 * e))),
                Math.max(0, Math.min(255, (1.164 * c + 2.018 * d)))
            ];
        }

        function convertToRGBA(rasters, width, height, fileDirectory) {
            const total = width * height;
            const rgba = new Uint8ClampedArray(total * 4);
            const isYCbCr = fileDirectory.PhotometricInterpretation === 6;

            // Optimized loops
            if (isYCbCr && rasters.length === total * 3) {
                for (let i=0, j=0; i<rasters.length; i+=3, j+=4) {
                    const [r, g, b] = ycbcrToRgb(rasters[i], rasters[i+1], rasters[i+2]);
                    rgba[j]=r; rgba[j+1]=g; rgba[j+2]=b; rgba[j+3]=255;
                }
            } else if (rasters.length === total * 3) {
                for (let i=0, j=0; i<rasters.length; i+=3, j+=4) {
                    rgba[j]=rasters[i]; rgba[j+1]=rasters[i+1]; rgba[j+2]=rasters[i+2]; rgba[j+3]=255;
                }
            } else if (rasters.length === total * 4) {
                return new Uint8ClampedArray(rasters);
            } else {
                throw new Error("Unsupported channel count");
            }
            return rgba;
        }

        // --- LOADING LOGIC ---
        async function loadBackbone(file) {
            try {
                log(`Loading Backbone: ${file.name}...`);
                const buffer = await file.arrayBuffer();
                backboneSess = await ort.InferenceSession.create(buffer, { executionProviders: ['wasm'] });
                document.getElementById('box-backbone').classList.add('loaded');
                log("‚úÖ Backbone Ready.");
                checkReady();
            } catch(e) { log(`Backbone Error: ${e.message}`, true); }
        }

        async function loadClassifiers(files) {
            const list = document.getElementById('model-list');
            list.innerHTML = "";
            classifiers = [];
            
            for (const file of files) {
                try {
                    const name = file.name.replace(/\.[^/.]+$/, "").replace(/_/g, " "); // Clean name
                    log(`Loading Task: ${name}...`);
                    const buffer = await file.arrayBuffer();
                    const sess = await ort.InferenceSession.create(buffer, { executionProviders: ['wasm'] });
                    
                    classifiers.push({ name: name, session: sess });
                    
                    const li = document.createElement('li');
                    li.innerHTML = `<div class="name">${name}</div> <div style="color:green; font-size:0.7rem;">‚óè READY</div>`;
                    list.appendChild(li);
                } catch(e) { log(`Failed: ${file.name}`, true); }
            }
            if(classifiers.length > 0) document.getElementById('box-classifiers').classList.add('loaded');
            checkReady();
        }

        document.getElementById('file-backbone').onchange = e => loadBackbone(e.target.files[0]);
        document.getElementById('file-classifiers').onchange = e => loadClassifiers(e.target.files);

        // --- SLIDE LOGIC ---
        document.getElementById('file-slide').onchange = async (e) => {
            try {
                log("Reading Slide Headers...");
                tiff = await GeoTIFF.fromBlob(e.target.files[0]);
                
                // Setup Levels
                const count = await tiff.getImageCount();
                const select = document.getElementById('level-select');
                select.innerHTML = "";
                
                for(let i=0; i<count; i++) {
                    const img = await tiff.getImage(i);
                    const opt = document.createElement("option");
                    opt.value = i;
                    opt.text = `Level ${i}: ${img.getWidth()} x ${img.getHeight()} px`;
                    select.appendChild(opt);
                }
                document.getElementById('level-container').style.display = 'block';
                
                // Auto-select level 1 if available (faster demo), else 0
                const defaultIdx = count > 1 ? 0 : 0; 
                select.value = defaultIdx;
                
                await loadLevel(defaultIdx);
                document.getElementById('box-slide').classList.add('loaded');
                checkReady();
            } catch(e) { log(`Slide Error: ${e.message}`, true); }
        };

        document.getElementById('level-select').onchange = e => loadLevel(parseInt(e.target.value));

        async function loadLevel(index) {
            tiffImage = await tiff.getImage(index);
            const w = tiffImage.getWidth();
            const h = tiffImage.getHeight();
            log(`Switched to Level ${index} (${w}x${h})`);
            
            initCanvas(w, h);
            
            if (w*h < MAX_PREVIEW_PIXELS) await generateOverview(tiffImage);
            else await tryGeneratePyramidOverview(tiff);
        }

        function initCanvas(w, h) {
            const c = document.getElementById('wsi-vis');
            const wrapper = document.getElementById('wsi-wrapper');
            // Aspect ratio fit
            const scale = Math.min(wrapper.clientWidth/w, wrapper.clientHeight/h);
            c.width = w * scale;
            c.height = h * scale;
            
            const ctx = c.getContext('2d');
            ctx.fillStyle = "#ffffff";
            ctx.fillRect(0, 0, c.width, c.height);
            ctx.fillStyle = "#999";
            ctx.textAlign = "center";
            ctx.font = "14px sans-serif";
            ctx.fillText("Loading Map...", c.width/2, c.height/2);
        }

        async function generateOverview(img) {
            await renderToCanvas(img);
        }

        async function tryGeneratePyramidOverview(handler) {
            const count = await handler.getImageCount();
            for(let i=1; i<count; i++) {
                const sub = await handler.getImage(i);
                if(sub.getWidth()*sub.getHeight() < MAX_PREVIEW_PIXELS) {
                    await renderToCanvas(sub);
                    return;
                }
            }
            // White background if no thumb
            const c = document.getElementById('wsi-vis');
            const ctx = c.getContext('2d');
            ctx.fillStyle="#fff";
            ctx.fillRect(0,0,c.width,c.height);
        }

        async function renderToCanvas(source) {
            try {
                const w = source.getWidth();
                const h = source.getHeight();
                const rasters = await source.readRasters({interleave:true});
                const rgba = convertToRGBA(rasters, w, h, source.fileDirectory);
                const imgData = new ImageData(rgba, w, h);
                const bmp = await createImageBitmap(imgData);
                const c = document.getElementById('wsi-vis');
                c.getContext('2d').drawImage(bmp, 0, 0, c.width, c.height);
            } catch(e) { console.warn("Thumb failed"); }
        }

        function checkReady() {
            if(backboneSess && classifiers.length > 0 && tiffImage) {
                const btn = document.getElementById('btn-run');
                btn.disabled = false;
                btn.innerHTML = "üöÄ Run Analysis";
                btn.style.backgroundColor = "#0066cc";
            }
        }

        // --- FAST PROCESSING ---
        function isTissueRaw(rgba) {
            let tissue = 0;
            // Stride 64 = check 1 in 16 pixels
            for(let i=0; i<rgba.length; i+=64) {
                // Check if not white/gray
                if(rgba[i]<220 || rgba[i+1]<220 || rgba[i+2]<220) tissue++;
            }
            return tissue > ((rgba.length/4)/16)*0.05;
        }

        function toTensorRaw(rgba) {
            const f32 = new Float32Array(3 * TILE_SIZE * TILE_SIZE);
            const mean = [0.485, 0.456, 0.406];
            const std = [0.229, 0.224, 0.225];
            let p = 0;
            for(let i=0; i<rgba.length; i+=4) {
                f32[p] = (rgba[i]/255 - mean[0])/std[0];
                f32[p + TILE_SIZE**2] = (rgba[i+1]/255 - mean[1])/std[1];
                f32[p + 2*TILE_SIZE**2] = (rgba[i+2]/255 - mean[2])/std[2];
                p++;
            }
            return new ort.Tensor('float32', f32, [1, 3, TILE_SIZE, TILE_SIZE]);
        }

        // --- EXECUTION ---
        document.getElementById('btn-run').onclick = async () => {
            const btn = document.getElementById('btn-run');
            const doViz = document.getElementById('cb-viz').checked;
            
            btn.disabled = true; 
            btn.innerHTML = `<span style="animation:blink 1s infinite">Running...</span>`;
            
            let features = [];
            const w = tiffImage.getWidth();
            const h = tiffImage.getHeight();
            
            // Visuals
            const c = document.getElementById('wsi-vis');
            const ctx = c.getContext('2d');
            const scaleX = c.width / w;
            const scaleY = c.height / h;
            
            const xTiles = Math.ceil(w/TILE_SIZE);
            const yTiles = Math.ceil(h/TILE_SIZE);
            const total = xTiles * yTiles;
            
            log(`Starting run on ${total} tiles...`);
            let processed = 0;
            let accepted = 0;
            const startT = performance.now();

            // Feature Loop
            for (let y=0; y<h; y+=TILE_SIZE) {
                for (let x=0; x<w; x+=TILE_SIZE) {
                    const rW = Math.min(TILE_SIZE, w-x);
                    const rH = Math.min(TILE_SIZE, h-y);
                    
                    try {
                        const rasters = await tiffImage.readRasters({window:[x,y,x+rW,y+rH], interleave:true});
                        const rgba = convertToRGBA(rasters, rW, rH, tiffImage.fileDirectory);
                        
                        if(isTissueRaw(rgba)) {
                            if(doViz) {
                                ctx.fillStyle="rgba(16, 185, 129, 0.4)"; // Green
                                ctx.fillRect(x*scaleX, y*scaleY, rW*scaleX, rH*scaleY);
                            }
                            
                            const feeds = {};
                            feeds[backboneSess.inputNames[0]] = toTensorRaw(rgba);
                            const res = await backboneSess.run(feeds);
                            features.push(Array.from(res[backboneSess.outputNames[0]].data));
                            accepted++;
                        } else {
                            if(doViz) {
                                ctx.fillStyle="rgba(200,200,200,0.2)"; // Gray
                                ctx.fillRect(x*scaleX, y*scaleY, rW*scaleX, rH*scaleY);
                            }
                        }
                    } catch(e){}
                    
                    processed++;
                    if(processed%50===0 || processed===total) {
                        const pct = Math.round((processed/total)*100);
                        document.getElementById('p-bar').style.width = `${pct}%`;
                        document.getElementById('p-percent').innerText = `${pct}%`;
                        document.getElementById('p-status').innerText = `Scanning ${processed}/${total}`;
                        await new Promise(r=>setTimeout(r,0));
                    }
                }
            }
            
            log(`Extracted features for ${accepted} tiles.`);
            
            if(features.length === 0) {
                log("No tissue found!", true);
                btn.disabled = false; btn.innerText = "Run Analysis"; return;
            }

            // Inference Loop
            log(`Running ${classifiers.length} classifiers...`);
            const flatFeats = new Float32Array(features.flat());
            const bagTensor = new ort.Tensor('float32', flatFeats, [1, features.length, 512]);
            
            const tbody = document.getElementById('results-body');
            tbody.innerHTML = ""; 

            for (const clf of classifiers) {
                try {
                    const feeds = {};
                    feeds[clf.session.inputNames[0]] = bagTensor;
                    const res = await clf.session.run(feeds);
                    const logits = res[clf.session.outputNames[0]].data;
                    
                    const exps = logits.map(Math.exp);
                    const sum = exps.reduce((a,b)=>a+b);
                    const prob = exps[1]/sum; 
                    const isPos = prob > 0.5;
                    
                    // Draw Row
                    const row = `
                        <tr>
                            <td><strong>${clf.name}</strong></td>
                            <td><span class="badge ${isPos ? 'pos' : 'neg'}">${isPos ? 'POSITIVE' : 'NEGATIVE'}</span></td>
                            <td>
                                <div style="background:#eee; height:6px; width:60px; border-radius:3px; display:inline-block; vertical-align:middle; margin-right:5px;">
                                    <div style="background:${isPos?'#ef4444':'#16a34a'}; height:100%; width:${prob*100}%"></div>
                                </div>
                                ${(prob*100).toFixed(1)}%
                            </td>
                        </tr>
                    `;
                    tbody.innerHTML += row;
                    
                } catch(e) { log(`Error on ${clf.name}: ${e.message}`, true); }
            }
            
            const totalTime = ((performance.now() - startT)/1000).toFixed(2);
            log(`Complete in ${totalTime}s`);
            btn.disabled = false;
            btn.innerText = "Run Again";
        };
    </script>
</body>
</html>
